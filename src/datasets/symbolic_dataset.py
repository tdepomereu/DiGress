import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
import random
import pandas as pd

import torch
import networkx as nx
from torch_geometric.data import Data
from torch_geometric.utils import to_networkx
from src.datasets.abstract_dataset import AbstractDataModule, AbstractDatasetInfos
from torch_geometric.data import Data, InMemoryDataset
from src.utils import count_node_connections

from IPython.display import display, Image
from graphviz import Digraph

import pathlib
import os

from src.constants import UNARY, BINARY, MAX_DEPTH, N_FEATURES, NODE_TYPES, N_SAMPLES, MAX_LOG10_VAL, MIN_LOG10_VAL


print(f"PyTorch version: {torch.__version__}")
print(f"CUDA available: {torch.cuda.is_available()}")
print(f"CUDA device count: {torch.cuda.device_count()}")
if torch.cuda.is_available():
    print(f"Device Name: {torch.cuda.get_device_name(0)}")
    print(f"Current Device: {torch.cuda.current_device()}")
else:
    print("CUDA is not available. Using CPU instead.")


def generate_random_constant():
    """
    Generates a random constant.

    Returns:
        float: A random constant generated by raising 10 to a random power between -10 and 10.
    """
    pow = random.uniform(-10, 10)
    return 10**pow

def generate_expression_tree(max_depth=MAX_DEPTH, node_types=NODE_TYPES, current_depth=0):
    """
    Generates a random expression tree.

    Parameters:
        max_depth (int): The maximum depth of the tree.
        node_types (dict): Dictionary containing the types of nodes (operands, operators, unary_operators).

    Returns:
        tuple/str/float: A randomly generated expression tree.
    """
    
    if current_depth >= 2 and (max_depth == 0 or random.random() < 0.3):
        if random.random() < 2:#0.5:
            return random.choice(node_types['operands'])
        else:
            return generate_random_constant()

    operator = random.choice(node_types['operators'])
    if operator in node_types['unary_operators']:
        operand = generate_expression_tree(max_depth - 1, node_types, current_depth + 1)
        if operator == 'log':
            while isinstance(operand, (int, float)) and operand <= 0:
                operand = generate_random_constant()
        return (operator, operand)
    else:
        left = generate_expression_tree(max_depth - 1, node_types, current_depth + 1)
        right = generate_expression_tree(max_depth - 1, node_types, current_depth + 1)
        return (operator, left, right)

def tree_to_graph(tree, node_types=NODE_TYPES):
    """
    Converts an expression tree to a graph.

    Parameters:
        tree (tuple/str/float): The expression tree.

    Returns:
        Data: A PyTorch Geometric Data object representing the graph.
    """
    nodes = []
    edges = []
    node_features = []

    def add_node(node):
        if isinstance(node, tuple):
            operator = node[0]
            node_id = len(nodes)
            nodes.append(operator)
            node_features.append(
                [int(operator == op) for op in node_types['operators']] + 
                [0] * len(node_types['operands']) + 
                [0, 0.0]  # Placeholder for constant flag and value
            )
            
            if operator in node_types['unary_operators']:  # Unary operators
                child_id = add_node(node[1])
                edges.append([node_id, child_id])
            else:  # Binary operators
                left_id = add_node(node[1])
                right_id = add_node(node[2])
                edges.append([node_id, left_id])
                edges.append([node_id, right_id])
            
            return node_id
        else:
            node_id = len(nodes)
            nodes.append(node)
            if isinstance(node, (int, float)):  # Handle constants
                node_features.append(
                    [0] * (len(node_types['operators'])) + 
                    [0] * len(node_types['operands']) + 
                    [1, node]  # Flag indicating this is a constant and the constant value
                )
            else:  # Handle operands
                node_features.append(
                    [0] * (len(node_types['operators'])) + 
                    [int(node == op) for op in node_types['operands']] + 
                    [0, 0.0]  # Placeholder for constant flag and value
                )
            return node_id
    
    root_id = add_node(tree)

    if len(edges) == 0:
        edge_index = torch.empty((2, 0), dtype=torch.long)  # Handle the case where no edges are generated
    else:
        edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
 
    x = torch.tensor(node_features, dtype=torch.float)

    if edge_index.numel() == 0:
        edge_attr = torch.empty((0, 2), dtype=torch.float)  # Handle the case where no edges are generated
    else:
        edge_attr = torch.ones((edge_index.size(1), 2), dtype=torch.float)  # Set edge attributes to [0, 1]
    # Manually set the first column to 0
    edge_attr[:, 1] = 0

    edge_counts = count_node_connections(edge_index)
    # x = torch.cat([x, torch.tensor(edge_counts, dtype=torch.float).view(-1, 1)], dim=1)

    y = torch.zeros((1, 0), dtype=torch.float)

    return Data(x=x, edge_index=edge_index, edge_attr=edge_attr, y=y)

def get_label(node_feature, node_types=NODE_TYPES):
    """
    Gets the label for a node based on its features.

    Parameters:
        node_feature (list): The feature vector of the node.

    Returns:
        str/float: The label of the node.
    """
    node_feature = torch.tensor(node_feature)  # Ensure node_feature is a tensor
    if node_feature[0:len(node_types['operators']), 0].sum()==1:  # Operator
        index = int(torch.argmax(node_feature[1:len(node_types['operators']) + 1]))
        return node_types['operators'][index]
    elif node_feature[-2, 0] == 1:  # Constant
        return float(node_feature[-1, 0].item())  # Decode the constant value
    else:  # Operand
        index = int(torch.argmax(node_feature[len(node_types['operators']) + 1:-2, 0]))
        return node_types['operands'][index]

def graph_to_tree(data):
    """
    Converts a graph back to an expression tree.

    Parameters:
        data (Data): A PyTorch Geometric Data object representing the graph.

    Returns:
        tuple/str/float: The reconstructed expression tree.
    """
    G = to_networkx(data, node_attrs=['x'])
    labels = {i: get_label(node['x']) for i, node in G.nodes(data=True)}
    
    def build_tree(node):
        neighbors = list(G.neighbors(node))
        if len(neighbors) == 0:
            return labels[node]
        elif len(neighbors) == 1:
            return (labels[node], build_tree(neighbors[0]))
        else:
            left_subtree = build_tree(neighbors[0])
            right_subtree = build_tree(neighbors[1])
            return (labels[node], left_subtree, right_subtree)
    
    root = 0  # Assuming the root node is always node 0
    return build_tree(root)

def tree_to_sympy(tree):
    """
    Converts an expression tree to a SymPy expression.

    Parameters:
        tree (tuple/str/float): The expression tree.

    Returns:
        Basic: The SymPy expression.
    """
    if isinstance(tree, str):  # Operand
        return sp.symbols(tree)
    elif isinstance(tree, (int, float)):  # Constant
        return tree
    operator, *operands = tree
    sympy_operands = [tree_to_sympy(op) for op in operands]
    if operator == 'exp':
        return sp.exp(sympy_operands[0])
    elif operator == 'log':
        return sp.log(sympy_operands[0])
    elif operator == 'inv':
        return 1 / sympy_operands[0]
    elif operator == '+':
        return sympy_operands[0] + sympy_operands[1]
    elif operator == '-':
        return sympy_operands[0] - sympy_operands[1]
    elif operator == '*':
        return sympy_operands[0] * sympy_operands[1]
    elif operator == '/':
        return sympy_operands[0] / sympy_operands[1]

def visualize_tree(tree, node_id=0, graph=None, parent_id=None):
    """
    Visualizes an expression tree using Graphviz.

    Parameters:
        tree (tuple/str/float): The expression tree.
        node_id (int): The current node ID (default is 0).
        graph (Digraph): The current Graphviz Digraph object (default is None).
        parent_id (int): The parent node ID (default is None).

    Returns:
        Digraph: The Graphviz Digraph object representing the tree.
    """
    if graph is None:
        graph = Digraph()
    
    if isinstance(tree, tuple):
        operator = tree[0]
        graph.node(str(node_id), operator)
        if parent_id is not None:
            graph.edge(str(parent_id), str(node_id))
        
        child_id = node_id + 1
        graph = visualize_tree(tree[1], child_id, graph, node_id)
        if len(tree) > 2:
            sibling_id = child_id + count_nodes(tree[1])
            graph = visualize_tree(tree[2], sibling_id, graph, node_id)
    else:
        graph.node(str(node_id), str(tree))
        if parent_id is not None:
            graph.edge(str(parent_id), str(node_id))
    
    return graph

def count_nodes(tree):
    """
    Counts the number of nodes in an expression tree.

    Parameters:
        tree (tuple/str/float): The expression tree.

    Returns:
        int: The number of nodes in the tree.
    """
    if isinstance(tree, tuple):
        operator = tree[0]
        if len(tree) == 2:  # Unary operator
            return 1 + count_nodes(tree[1])
        else:  # Binary operator
            return 1 + count_nodes(tree[1]) + count_nodes(tree[2])
    else:
        return 1

def display_tree(tree):
    """
    Displays an expression tree using Graphviz and IPython.

    Parameters:
        tree (tuple/str/float): The expression tree.
    """
    graph = visualize_tree(tree)
    graph.format = 'png'
    graph.render(filename='expression_tree', view=False)
    display(Image(filename='expression_tree.png'))

def generate_random_table(n_features=N_FEATURES, 
                          n_samples=N_SAMPLES, 
                          min_log10=MIN_LOG10_VAL, 
                          max_log10=MAX_LOG10_VAL):
    """
    Generates a table of random values for n features between min_value and max_value.

    Parameters:
        n_features (int): Number of features (columns).
        n_samples (int): Number of samples (rows).
        min_log10 (int): Minimum log10 value for random data generation.
        max_log10 (int): Maximum log10 value for random data generation.

    Returns:
        DataFrame: A Pandas DataFrame containing the random values.
    """
    random_data = 10 ** np.random.uniform(low=min_log10, high=max_log10, size=(n_samples, n_features))
    feature_names = [f'x{i}' for i in range(n_features)]
    
    df = pd.DataFrame(random_data, columns=feature_names)
    
    return df

def generate_graph_and_data(max_depth=MAX_DEPTH,
                            node_types=NODE_TYPES,
                            n_features=N_FEATURES, 
                            n_samples=N_SAMPLES, 
                            min_log10=MIN_LOG10_VAL, 
                            max_log10=MAX_LOG10_VAL):
    """
    Generates a random expression tree, converts it to a graph, and generates corresponding data.

    Parameters:
        max_depth (int): The maximum depth of the tree.
        n_features (int): The number of features.
        n_samples (int): The number of samples.
        min_log10 (int): Minimum log10 value for random data generation.
        max_log10 (int): Maximum log10 value for random data generation.

    Returns:
        tuple: A tuple containing the graph (Data) and the dataset (DataFrame).
    """
    tree = generate_expression_tree(max_depth, node_types)
    graph = tree_to_graph(tree, node_types)

    sympy_expr = tree_to_sympy(tree)
    features_tuple = tuple(['x' + str(i) for i in range(n_features)])
    sympy_lambda = sp.lambdify(features_tuple, sympy_expr, 'numpy')

    dataset = generate_random_table(n_features, n_samples, min_log10, max_log10)
    dataset['y'] = dataset.apply(lambda row: sympy_lambda(*tuple(row)), axis=1)

    return graph, dataset


class GeneratedGraphDataset(InMemoryDataset):
    def __init__(self, split, root, transform=None, pre_transform=None, pre_filter=None):
        self.split = split
        self.num_graphs = 2000
        super().__init__(root, transform, pre_transform, pre_filter)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return ['train.pt', 'val.pt', 'test.pt']

    @property
    def processed_file_names(self):
        return [self.split + '.pt']

    def download(self):
        pass

    def process(self):
        data_list = []
        for _ in range(self.num_graphs):
            graph = tree_to_graph(generate_expression_tree())
            data_list.append(graph)
        print('Dataset generation done')

        torch.save(self.collate(data_list), self.processed_paths[0])


class GeneratedGraphDataModule(AbstractDataModule):
    def __init__(self, cfg, n_graphs=2000):
        self.cfg = cfg
        self.datadir = cfg.dataset.datadir
        base_path = pathlib.Path(os.path.realpath(__file__)).parents[2]
        root_path = os.path.join(base_path, self.datadir)
        datasets = {
            'train': GeneratedGraphDataset(split='train', root=root_path),
            'val': GeneratedGraphDataset(split='val', root=root_path),
            'test': GeneratedGraphDataset(split='test', root=root_path)
        }

        super().__init__(cfg, datasets)
        self.inner = self.train_dataset

    def __getitem__(self, item):
        return self.inner[item]


class GeneratedDatasetInfos(AbstractDatasetInfos):
    def __init__(self, datamodule, dataset_config):
        self.datamodule = datamodule
        self.name = 'generated_graphs'
        self.n_nodes = self.datamodule.node_counts()
        self.node_types = self.datamodule.node_types()
        self.edge_types = self.datamodule.edge_counts()
        super().complete_infos(self.n_nodes, self.node_types)